{"meta":{"title":"星空","subtitle":"记录浩瀚星空的点滴","description":"期待自己的星辰","author":"Wang Kun","url":"http://yoursite.com"},"posts":[{"title":"UML 类图常见关系","slug":"UML-类图常见关系","date":"2017-03-30T14:21:36.000Z","updated":"2017-03-30T15:15:56.660Z","comments":true,"path":"2017/03/30/UML-类图常见关系/","link":"","permalink":"http://yoursite.com/2017/03/30/UML-类图常见关系/","excerpt":"","text":"Wiki中给出UML的定义，旨在可视化系统设计。 The Unified Modeling Language (UML) is a general-purpose, developmental, modeling language in the field of software engineering, that is intended to provide a standard way to visualize the design of a system. 在面向对象编程中，UML用于绘制需求分析时的用例图（功能模型），系统设计时的类图（对象模型），系统实现时的时序图，状态图（动态模型）等。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"UML","slug":"UML","permalink":"http://yoursite.com/tags/UML/"}]},{"title":"Java 对象序列化","slug":"Java-对象序列化","date":"2017-03-28T02:56:24.000Z","updated":"2017-03-28T02:56:24.326Z","comments":true,"path":"2017/03/28/Java-对象序列化/","link":"","permalink":"http://yoursite.com/2017/03/28/Java-对象序列化/","excerpt":"","text":"","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Java IO浅析","slug":"Java-IO浅析","date":"2017-03-22T06:30:19.000Z","updated":"2017-04-03T05:44:14.488Z","comments":true,"path":"2017/03/22/Java-IO浅析/","link":"","permalink":"http://yoursite.com/2017/03/22/Java-IO浅析/","excerpt":"","text":"Java IO即Java中的输入(Input)和输出(Output)。Java IO根据读写时是否阻塞，可分为阻塞IO(Blocking IO, BIO)和非阻塞IO(Non-blocking IO, NIO)。 本文主要讲述BIO，其主要类位于java.io包下，根据操作接口的不同，可以分为基于字节的读写(InputStream, OutputStream)和基于字符的读写(Reader, Writer)。本文将分别介绍这四个类家族及家族间的关系。 ps:本文类图参照JDK 8源码 InputStream家族InputStream家族包括类InputStream及其子孙类，类图如下图所示。 AutoCloseable和Closeable接口，AutoCloseable是在JDK 7新加入的接口，它使得try-with-resources成为可能，同时改善了Closeable接口中close方法抛出IOException的局限，选择抛出Exception。为了向前兼容，选择让Closeable接口继承AutoCloseable，专门定义IO读写中资源的关闭。 InputStream类，抽象类，定义了子类必须实现的int read() throw IOException的抽象方法。 FileInputStream类，通过JNI实现了从某个文件中读取数据的read()方法及其重载方法。 AudioInputStream类，对stream字节流组装成“帧”，read()方法及重载方法只能读取若干帧。 ByteArrayInputStream类，将一个字节数组作为输入流进行读取。 PipedInputStream类，用于多线程间的管道通讯，线程A从PipedInputStream的缓冲数组中读取数据，线程B利用PipedOutputStream向PipedInputStream的缓冲数组写入数据，从而完成通讯。 SequenceInputStream类，将多个InputStream首尾连接，作为一个输入流来读取。 ObjectInputStream类，和ObjectOutputStream对应，分别用于类的序列化中对象的读和写，详情。 FilterInputStream类，对输入流in进行过滤，加工，诸多子类通过重写read()及其重载方法自定义过滤方式，呈现不同功能。 BufferedInputStream类，为输入流in设置缓冲区，每次直接从缓冲区中读取，并根据上次mark的位置动态的调整并填充缓冲区。 DataInputStream类，对输入字节流in进行解析，组装成基本类型和UTF字符串。 DeflaterInputStream类，对输入流in进行deflate压缩，读取的是压缩后的字节流。 InflaterInputStream类，对deflate压缩流in进行解压，读取的是解压后的字节流。 LineNumberInputStream类，Deprecated，将字节流看成是字符流，如遇到’\\n’,’\\r’,’\\r\\n’，则行数加一。 PushBackInputStream类，允许在对输入流读取时撤销读，比如在LineNumberInputStream中需要预取下一个字符，判断是否换行符，如果不是，需要撤销这次读。 DigestInputStream类，使用MessageDigest对输入流in提取摘要，读取的是摘要的字节流。 Reader家族Reader家族包括类Reader及其子孙类，类图如下图所示。 Readable接口，定义了int read(java.nio.CharBuffer cb)接口，供调用者读取可读的字符流。 Reader抽象类，定义了子类需实现的抽象方法，int read(char cbuf[], int off, int len)。 CharArrayReader类，使用缓冲数组buf作为字符输入流。 StringReader类，使用字符串str作为字符输入流。 参考文献","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"IO","slug":"IO","permalink":"http://yoursite.com/tags/IO/"}]},{"title":"基本排序","slug":"sorting","date":"2016-06-05T09:09:28.000Z","updated":"2017-03-07T07:11:43.656Z","comments":true,"path":"2016/06/05/sorting/","link":"","permalink":"http://yoursite.com/2016/06/05/sorting/","excerpt":"","text":"排序根据算法的复杂度（平均复杂度）可以大致分为一下三类： $O(n^2)$：冒泡排序（Bubble Sort），插入排序（Inserttion Sort），选择排序（Selection Sort） $O(nlogn)$：归并排序（Merge Sort），堆排序（Heap Sort），快速排序（Quick Sort） $O(n)$：计数排序（Counting Sort），基数排序（Radix Sort） 排序根据算法的稳定性（对于相同的元素是否能够在排序前后保证相对顺序），可以两类： 稳定排序：冒泡排序（Bubble Sort），插入排序（Inserttion Sort），归并排序（Merge Sort），计数排序（Counting Sort），计数排序（Counting Sort） 不稳定排序：选择排序（Selection Sort），快速排序（Quick Sort），堆排序（Heap Sort） 冒泡排序冒泡排序是模拟气泡从水底部上浮的过程，对于一个待排序的序列而言，较小的数会一直向上“浮”，直至所有的较小的数都在较大数的上面（左边），就完成了排序。以下为Java实现， 可以看出冒泡排序是稳定排序。1234567891011void bubbleSort(int[] nums) &#123; for(int i = 0; i &lt; nums.length; i++) &#123; for(int j = nums.length - 2; j &gt;= 0; j--) &#123; if(nums[j] &gt; nums[j+1]) &#123; int tmp = nums[j+1]; nums[j+1] = nums[j]; nums[j] = tmp; &#125; &#125; &#125;&#125; 插入排序插入排序主要是通过将当前元素插入到前面已经排好序的序列当中来完成排序。以下为Java实现。插入排序有一种双排的实现方式，每次考虑两个元素$a$, $b$$（a&gt;b）$，先排好$a$，接着从$a$的位置排$b$，可以减少比较次数。1234567891011void insertionSort(int[] nums) &#123; for(int i = 1; i &lt; nums.length; i++) &#123; for(int j = i; j &gt; 0; j--) &#123; if(nums[j-1] &gt; nums[j]) &#123; int tmp = nums[j]; nums[j] = nums[j-1]; nums[j-1] = tmp; &#125; &#125; &#125;&#125; 选择排序每次选择未排序序列的最小值，追加到已排好序列的末端。一下为Java实现，选择排序为不稳定排序，如3，3，1。123456789101112131415void selectionSort(int[] nums) &#123; for(int i = 0; i &lt; nums.length; i++) &#123; int min = nums[i], pos = i; for(int j = i+1; j &lt; nums.length; j++) &#123; if(nums[j] &lt; min) &#123; min = nums[j]; pos = j; &#125; &#125; if(pos != i) &#123; int tmp = nums[i]; nums[i] = nums[pos]; nums[pos] = tmp; &#125; &#125; &#125; 归并排序归并排序，从名字上就可以大致看出来有归一合并的过程。将n长度的排序问题分解成长度相等$（\\frac n2， n-\\frac n2）$的排序子问题，之后将子问题的结果（两个排好序的子序列）合并成一个序列，完成排序。1234567891011121314151617181920void merge(int[] nums, int left, int right) &#123; int mid = (left + right)/2; int[] tmp = new int[right - left + 1]; int cnta = left, cntb = mid+1, cnt = 0; while (cnta &lt;= mid &amp;&amp; cntb &lt;= right) &#123; if(nums[cnta] &gt; nums[cntb]) tmp[cnt++] = nums[cntb++]; else tmp[cnt++] = nums[cnta++]; &#125; while (cnta &lt;= mid) tmp[cnt++] = nums[cnta++]; while (cntb &lt;= right) tmp[cnt++] = nums[cntb++]; for(int i = left; i &lt;= right; i++) nums[i] = tmp[i-left]; &#125; void mergeSort(int[] nums, int left, int right) &#123; if(left &gt;= right) return; int mid = (left + right)/2; mergeSort(nums, left, mid); mergeSort(nums, mid+1, right); merge(nums, left, right); &#125; 堆排序堆排序是利用最大堆的特性（根是所有对结点中键值最大的），首先构建堆（$O(n)$），每次将根与堆的最后一个元素进行交换，并且将堆的大小减少1（并没有把最后的堆元素删除），调整堆使其保证最大堆的特性，当堆的大小减为1时，再层次遍历堆，完成排序。12345678910111213141516171819202122232425262728293031323334//建堆void buildHeap(int[] nums, int size) &#123; for(int i = (size &gt;&gt;&gt;1); i &gt;= 1; i--) &#123; heapify(nums, size, i); &#125;&#125;//调整堆void heapify(int[] nums, int size, int i) &#123; int l = i &lt;&lt; 1; int r = (i &lt;&lt; 1) + 1; int largest = i; if(l &lt;= size &amp;&amp; nums[l] &gt; nums[i]) largest = l; if(r &lt;= size &amp;&amp; nums[r] &gt; nums[largest]) largest = r; if(largest != i) &#123; int tmp = nums[largest]; nums[largest] = nums[i]; nums[i] = tmp; heapify(nums, size, largest); &#125;&#125;//堆排序void heapSort(int[] nums, int size) &#123; //nums从1开始, size是数据的实际大小（不包括下标为0的元素） buildHeap(nums, size); for(int i = size; i &gt;= 2; i--) &#123; int tmp = nums[i]; nums[i] = nums[1]; nums[1] = tmp; heapify(nums, i-1, 1); &#125;&#125; 快速排序和归并排序相同，快排采用分治的策略，在序列中选取一个$pivot$， 把一个序列分为两个子序列，使得一个序列的所有值都小于等于$pivot$， 另一个序列的所有值都大于等于$pivot$，之后递归处理两个子序列。快排是不稳定排序，如3,4,5,4,1,2，$pivot为3$。以下为Java实现。快排的平均复杂度为$O(nlogn)$，最坏的复杂度为$O(n^2)$。123456789101112131415161718192021222324void swap(int[] nums, int x, int y) &#123; int temp = nums[x]; nums[x] = nums[y]; nums[y] = temp;&#125;void quickSort(int[] nums, int start, int end) &#123; if (start &gt;= end) return; int pivot = nums[start]; int left = start, right = end-1; swap(nums, start, end); while (left &lt; right) &#123; while (left &lt; right &amp;&amp; nums[left] &lt; pivot) left++; while (left &lt; right &amp;&amp; nums[right] &gt;= pivot) right--; if(left &lt; right) swap(nums, left, right); &#125; swap(nums, left, end); quickSort(nums, start, left - 1); quickSort(nums, left + 1, end);&#125; 计数排序计数排序直接使用一个数组来保存该元素出现的次数，之后对所有的计数进行累加，反向填充目标数组。一下为Java实现。123456789101112131415161718int[] countingSort(int[] nums) &#123; int[] ans = new int[nums.length]; int min = nums[0], max = nums[0]; for(int i = 0; i &lt; nums.length; i++) &#123; min = Math.min(min, nums[i]); max = Math.max(max, nums[i]); &#125; int[] c = new int[max-min+1]; for(int i = 0; i &lt; nums.length; i++) &#123; c[nums[i] - min]++; &#125; for(int i = 1; i &lt; c.length; i++) c[i] += c[i-1]; for(int i = nums.length-1; i &gt;= 0; i--) ans[--c[nums[i]-min]] = nums[i]; return ans;&#125; 基数排序基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数进行排序。其复杂度为$O(dn)$，$d$为整数位数。一下为Java代码实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int maxbit(int nums[], int n) //辅助函数，求数据的最大位数 &#123; int maxnums = nums[0]; ///&lt; 最大数 /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。 for (int i = 1; i &lt; n; ++i) &#123; if (maxnums &lt; nums[i]) maxnums = nums[i]; &#125; int d = 1; int p = 10; while (maxnums &gt;= p) &#123; p *= 10; ++d; &#125; return d; &#125; void radixsort(int nums[], int n) //基数排序 &#123; int d = maxbit(nums, n); int[] tmp = new int[n]; int[] count = new int[10]; //计数器 int i, j, k; int radix = 1; for(i = 1; i &lt;= d; i++) //进行d次排序 &#123; for(j = 0; j &lt; 10; j++) count[j] = 0; //每次分配前清空计数器 for(j = 0; j &lt; n; j++) &#123; k = (nums[j] / radix) % 10; //统计每个桶中的记录数 count[k]++; &#125; for(j = 1; j &lt; 10; j++) count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶 for(j = n - 1; j &gt;= 0; j--) //将所有桶中记录依次收集到tmp中 &#123; k = (nums[j] / radix) % 10; tmp[count[k] - 1] = nums[j]; count[k]--; &#125; for(j = 0; j &lt; n; j++) //将临时数组的内容复制到nums中 nums[j] = tmp[j]; radix = radix * 10; &#125; &#125; 延伸阅读数学之美番外篇：快排为什么那样快","raw":null,"content":null,"categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/categories/算法与数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]}]}